# Generated by the openapi3 package: do not edit by hand
# Source: openapi.yaml

#' Computes all reachable locations from a given stop within a set duration.
#' Each result entry will contain the fastest travel duration and the number of connections used.
#'
#' @param one `latitude,longitude[,level]` tuple with
#' - latitude and longitude in degrees
#' - (optional) level: the OSM level (default: 0)
#' 
#' OR
#' 
#' stop id
#' @param time Optional. Defaults to the current time.
#' 
#' Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
#' @param maxTravelTime maximum travel time in minutes
#' 
#' @param arriveBy true = all to one,
#' false = one to all
#' @param maxTransfers The maximum number of allowed transfers (i.e. interchanges between transit legs,
#' pre- and postTransit do not count as transfers).
#' `maxTransfers=0` searches for direct transit connections without any transfers.
#' If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.),
#' send an empty `transitModes` parameter instead.
#' 
#' If not provided, the routing uses the server-side default value
#' which is hardcoded and very high to cover all use cases.
#' 
#' *Warning*: Use with care. Setting this too low can lead to
#' optimal (e.g. the fastest) journeys not being found.
#' If this value is too low to reach the destination at all,
#' it can lead to slow routing performance.
#' 
#' In plan endpoints before v3, the behavior is off by one,
#' i.e. `maxTransfers=0` only returns non-transit connections.
#' @param minTransferTime Optional. Default is 0 minutes.
#' 
#' Minimum transfer time for each transfer in minutes.
#' @param additionalTransferTime Optional. Default is 0 minutes.
#' 
#' Additional transfer time reserved for each transfer in minutes.
#' @param transferTimeFactor Optional. Default is 1.0
#' 
#' Factor to multiply minimum required transfer times with.
#' Values smaller than 1.0 are not supported.
#' @param maxMatchingDistance Optional. Default is 25 meters.
#' 
#' Maximum matching distance in meters to match geo coordinates to the street network.
#' @param useRoutedTransfers Optional. Default is `false`.
#' 
#' Whether to use transfers routed on OpenStreetMap data.
#' @param pedestrianProfile Optional. Default is `FOOT`.
#' 
#' Accessibility profile to use for pedestrian routing in transfers
#' between transit connections and the first and last mile respectively.
#'
#' Allowed values: FOOT, WHEELCHAIR.
#' @param elevationCosts Optional. Default is `NONE`.
#' 
#' Set an elevation cost profile, to penalize routes with incline.
#' - `NONE`: No additional costs for elevations. This is the default behavior
#' - `LOW`: Add a low cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if small detours are required.
#' - `HIGH`: Add a high cost for increase in elevation and incline along the way. This will prefer routes with less ascent, if larger detours are required.
#' 
#' As using an elevation costs profile will increase the travel duration,
#' routing through steep terrain may exceed the maximal allowed duration,
#' causing a location to appear unreachable.
#' Increasing the maximum travel time for these segments may resolve this issue.
#' 
#' The profile is used for routing on both the first and last mile.
#' 
#' Elevation cost profiles are currently used by following street modes:
#' - `BIKE`
#'
#' Allowed values: NONE, LOW, HIGH.
#' @param transitModes Optional. Default is `TRANSIT` which allows all transit modes (no restriction).
#' Allowed modes for the transit part. If empty, no transit connections will be computed.
#' For example, this can be used to allow only `METRO,SUBWAY,TRAM`.
#'
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, FLEX, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, METRO, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, CABLE_CAR, FUNICULAR, AREAL_LIFT, OTHER.
#' @param preTransitModes Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
#' - `arriveBy=true`: Currently not used
#' - `arriveBy=false`: Only applies if the `one` place is a coordinate (not a transit stop).
#' 
#' A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
#'
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, FLEX, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, METRO, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, CABLE_CAR, FUNICULAR, AREAL_LIFT, OTHER.
#' @param postTransitModes Optional. Default is `WALK`. The behavior depends on whether `arriveBy` is set:
#' - `arriveBy=true`: Only applies if the `one` place is a coordinate (not a transit stop).
#' - `arriveBy=false`: Currently not used
#' 
#' A list of modes that are allowed to be used from the last transit stop to the `to` coordinate. Example: `WALK,BIKE_SHARING`.
#'
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, FLEX, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, METRO, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, CABLE_CAR, FUNICULAR, AREAL_LIFT, OTHER.
#' @param requireBikeTransport Optional. Default is `false`.
#' 
#' If set to `true`, all used transit trips are required to allow bike carriage.
#' @param requireCarTransport Optional. Default is `false`.
#' 
#' If set to `true`, all used transit trips are required to allow car carriage.
#' @param maxPreTransitTime Optional. Default is 15min which is `900`.
#' - `arriveBy=true`: Currently not used
#' - `arriveBy=false`: Maximum time in seconds for the street leg at `one` location.
#' @param maxPostTransitTime Optional. Default is 15min which is `900`.
#' - `arriveBy=true`: Maximum time in seconds for the street leg at `one` location.
#' - `arriveBy=false`: Currently not used
#' @param .return_as How to return the response. One of 'list' (default), 'string', or 'raw'.
#' @param .json_parser JSON parser when `.return_as = 'list'`. One of 'RcppSimdJson' (default) or 'jsonlite'.
#' @param .headers Named list of additional HTTP headers to include.
#' @param .auth Bearer token string or a function `function(req) req` to apply custom auth.
#' @param .throttle_rate Requests per second (numeric). If set, throttling is applied.
#' @param .build_only If TRUE, return the unperformed request object.
#' @param .server Override the server URL for this call.
#' @param .endpoint A string to override the path for this specific request (e.g., '/v2/users/{id}'). If provided, it will be used instead of the default path from the specification.
#' @param .referer Optional Referer header value.
#' @param .req_options Named list of curl options passed to `httr2::req_options()`.
#' @param .handle_response Optional function `function(resp) ...` to post-process the response.
#' @param .json_auto_unbox If TRUE (default), auto-unbox scalar JSON values for request bodies.
#' @export
mc_oneToAll <- function(one = NULL, time = NULL, maxTravelTime = NULL, arriveBy = NULL, maxTransfers = NULL, minTransferTime = NULL, additionalTransferTime = NULL, transferTimeFactor = NULL, maxMatchingDistance = NULL, useRoutedTransfers = NULL, pedestrianProfile = NULL, elevationCosts = NULL, transitModes = NULL, preTransitModes = NULL, postTransitModes = NULL, requireBikeTransport = NULL, requireCarTransport = NULL, maxPreTransitTime = NULL, maxPostTransitTime = NULL, .return_as = NULL, .json_parser = NULL, .headers = NULL, .auth = NULL, .throttle_rate = NULL, .build_only = NULL, .server = NULL, .endpoint = NULL, .referer = NULL, .req_options = NULL, .handle_response = NULL, .json_auto_unbox = NULL) {
  # --- Self-contained Default Arguments ---
  default_return_as <- "raw"
  default_json_parser <- "RcppSimdJson"
  default_headers <- list(Accept = "*/*")
  default_auth <- NULL
  default_throttle_rate <- NULL
  default_build_only <- TRUE
  default_server <- "http://localhost:8080"
  default_referer <- NULL
  default_req_options <- NULL
  default_json_auto_unbox <- TRUE
  default_handle_response <- NULL

  # --- Request building ---
  server_url <- .server %||% default_server
  req <- httr2::request(server_url)
  req <- httr2::req_method(req, method = "GET")

  # Path parameters
  path_params <- list()
  path_template <- .endpoint %||% "/api/v1/one-to-all"
  if (length(path_params)) {
    # URL-encode each path value
    for (nm in names(path_params)) path_params[[nm]] <- curl::curl_escape(as.character(path_params[[nm]]))
  }
  path_expanded <- as.character(glue::glue_data(path_params, path_template))
  req <- httr2::req_url_path_append(req, path_expanded)

  # Query parameters
  query_params <- list()
  if (!is.null(one)) query_params[['one']] <- one
  if (!is.null(time)) query_params[['time']] <- time
  if (!is.null(maxTravelTime)) query_params[['maxTravelTime']] <- maxTravelTime
  if (!is.null(arriveBy)) query_params[['arriveBy']] <- arriveBy
  if (!is.null(maxTransfers)) query_params[['maxTransfers']] <- maxTransfers
  if (!is.null(minTransferTime)) query_params[['minTransferTime']] <- minTransferTime
  if (!is.null(additionalTransferTime)) query_params[['additionalTransferTime']] <- additionalTransferTime
  if (!is.null(transferTimeFactor)) query_params[['transferTimeFactor']] <- transferTimeFactor
  if (!is.null(maxMatchingDistance)) query_params[['maxMatchingDistance']] <- maxMatchingDistance
  if (!is.null(useRoutedTransfers)) query_params[['useRoutedTransfers']] <- useRoutedTransfers
  if (!is.null(pedestrianProfile)) query_params[['pedestrianProfile']] <- pedestrianProfile
  if (!is.null(elevationCosts)) query_params[['elevationCosts']] <- elevationCosts
  if (!is.null(transitModes)) query_params[['transitModes']] <- transitModes
  if (!is.null(preTransitModes)) query_params[['preTransitModes']] <- preTransitModes
  if (!is.null(postTransitModes)) query_params[['postTransitModes']] <- postTransitModes
  if (!is.null(requireBikeTransport)) query_params[['requireBikeTransport']] <- requireBikeTransport
  if (!is.null(requireCarTransport)) query_params[['requireCarTransport']] <- requireCarTransport
  if (!is.null(maxPreTransitTime)) query_params[['maxPreTransitTime']] <- maxPreTransitTime
  if (!is.null(maxPostTransitTime)) query_params[['maxPostTransitTime']] <- maxPostTransitTime
  if (length(query_params) > 0) {
    req <- do.call(httr2::req_url_query, c(list(req), query_params))
  }



  # --- Control arguments ---
  auth <- .auth %||% default_auth
  if (!is.null(auth)) {
    if (is.character(auth)) {
      req <- httr2::req_auth_bearer_token(req, auth)
    } else if (is.function(auth)) {
      req <- auth(req)
    } else {
      stop('`.auth` must be a token string or a function(req) that returns a request.', call. = FALSE)
    }
  }

  headers <- default_headers
  if (!is.null(.headers)) headers <- c(headers, .headers)
  if (!is.null(headers)) req <- do.call(httr2::req_headers, c(list(req), headers))
  # Ensure Accept exists
  if (is.null(headers) || !any(tolower(names(headers)) == 'accept')) req <- httr2::req_headers(req, Accept = '*/*')

  referer <- .referer %||% default_referer
  if (!is.null(referer)) req <- httr2::req_headers(req, Referer = referer)

  throttle_rate <- .throttle_rate %||% default_throttle_rate
  if (!is.null(throttle_rate)) req <- httr2::req_throttle(req, rate = throttle_rate)

  req_opts <- .req_options %||% default_req_options
  if (!is.null(req_opts)) {
    if (!is.list(req_opts)) stop('`.req_options` must be a named list.', call. = FALSE)
    req <- do.call(httr2::req_options, c(list(req), req_opts))
  }

  build_only <- .build_only %||% default_build_only
  if (isTRUE(build_only)) return(req)

  resp <- httr2::req_perform(req)

  handler <- .handle_response %||% default_handle_response
  if (!is.null(handler) && is.function(handler)) return(handler(resp))

  # Robust response handling
  return_as <- .return_as %||% default_return_as
  return_as <- if (is.null(return_as)) 'list' else as.character(return_as)[1L]
  json_parser <- .json_parser %||% default_json_parser
  json_parser <- if (is.null(json_parser)) 'RcppSimdJson' else as.character(json_parser)[1L]
  switch(return_as,
    'raw' = return(resp),
    'string' = return(httr2::resp_body_string(resp)),
    'list' = switch(
      json_parser,
      'RcppSimdJson' = {
        if (!requireNamespace('RcppSimdJson', quietly = TRUE)) {
          return(httr2::resp_body_json(resp))
        }
        RcppSimdJson::fparse(httr2::resp_body_string(resp))
      },
      'jsonlite' = httr2::resp_body_json(resp),
      stop("Unknown .json_parser: '", json_parser, "'.", call. = FALSE)
    ),
    stop("Unknown .return_as: '", return_as, "'.", call. = FALSE)
  )
}

