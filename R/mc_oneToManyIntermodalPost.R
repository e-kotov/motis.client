# Generated by the openapi3 package: do not edit by hand
# Source: openapi.yaml

#' One to many routing
#' Computes the minimal duration from one place to many or vice versa.
#' The order in the response array corresponds to the order of coordinates of the `many` parameter in the query.
#'
#' @param one <string> `latitude,longitude[,level]` tuple with - latitude and longitude in degrees - (optional) level: the OSM level (default: 0) OR stop id
#' @param many <array> array of: `latitude,longitude[,level]` tuple with - latitude and longitude in degrees - (optional) level: the OSM level (default: 0) OR stop id The number of accepted locations is limited by server config variable `onetomany_max_many`.
#' @param time <string> Optional. Defaults to the current time. Departure time ($arriveBy=false) / arrival date ($arriveBy=true),
#' @param maxTravelTime <integer> The maximum travel time in minutes. If not provided, the routing uses the value hardcoded in the server which is usually quite high. *Warning*: Use with care. Setting this too low can lead to optimal (e.g. the least transfers) journeys not being found. If this value is too low to reach the destination at all, it can lead to slow routing performance.
#' @param maxMatchingDistance <number> maximum matching distance in meters to match geo coordinates to the street network
#' @param arriveBy <boolean> Optional. Defaults to false, i.e. one to many search true = many to one false = one to many
#' @param maxTransfers <integer> The maximum number of allowed transfers (i.e. interchanges between transit legs, pre- and postTransit do not count as transfers). `maxTransfers=0` searches for direct transit connections without any transfers. If you want to search only for non-transit connections (`FOOT`, `CAR`, etc.), send an empty `transitModes` parameter instead. If not provided, the routing uses the server-side default value which is hardcoded and very high to cover all use cases. *Warning*: Use with care. Setting this too low can lead to optimal (e.g. the fastest) journeys not being found. If this value is too low to reach the destination at all, it can lead to slow routing performance.
#' @param minTransferTime <integer> Optional. Default is 0 minutes. Minimum transfer time for each transfer in minutes.
#' @param additionalTransferTime <integer> Optional. Default is 0 minutes. Additional transfer time reserved for each transfer in minutes.
#' @param transferTimeFactor <number> Optional. Default is 1.0 Factor to multiply minimum required transfer times with. Values smaller than 1.0 are not supported.
#' @param useRoutedTransfers <boolean> Optional. Default is `false`. Whether to use transfers routed on OpenStreetMap data.
#' @param pedestrianProfile <string> Different accessibility profiles for pedestrians.
#' Allowed values: FOOT, WHEELCHAIR.
#' @param pedestrianSpeed <number> Average speed for pedestrian routing in meters per second
#' @param cyclingSpeed <number> Average speed for bike routing in meters per second
#' @param elevationCosts <string> Different elevation cost profiles for street routing. Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer. - `NONE`: Ignore elevation data for routing. This is the default behavior - `LOW`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller. - `HIGH`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
#' Allowed values: NONE, LOW, HIGH.
#' @param transitModes <array> Optional. Default is `TRANSIT` which allows all transit modes (no restriction). Allowed modes for the transit part. If empty, no transit connections will be computed. For example, this can be used to allow only `SUBURBAN,SUBWAY,TRAM`.
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, RIDE_SHARING, FLEX, DEBUG_BUS_ROUTE, DEBUG_RAILWAY_ROUTE, DEBUG_FERRY_ROUTE, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, SUBURBAN, FUNICULAR, AERIAL_LIFT, OTHER, AREAL_LIFT, METRO, CABLE_CAR.
#' @param preTransitModes <array> Optional. Default is `WALK`. Does not apply to direct connections (see `directMode`). A list of modes that are allowed to be used for the first mile, i.e. from the coordinates to the first transit stop. Example: `WALK,BIKE_SHARING`.
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, RIDE_SHARING, FLEX, DEBUG_BUS_ROUTE, DEBUG_RAILWAY_ROUTE, DEBUG_FERRY_ROUTE, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, SUBURBAN, FUNICULAR, AERIAL_LIFT, OTHER, AREAL_LIFT, METRO, CABLE_CAR.
#' @param postTransitModes <array> Optional. Default is `WALK`. Does not apply to direct connections (see `directMode`). A list of modes that are allowed to be used for the last mile, i.e. from the last transit stop to the target coordinates. Example: `WALK,BIKE_SHARING`.
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, RIDE_SHARING, FLEX, DEBUG_BUS_ROUTE, DEBUG_RAILWAY_ROUTE, DEBUG_FERRY_ROUTE, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, SUBURBAN, FUNICULAR, AERIAL_LIFT, OTHER, AREAL_LIFT, METRO, CABLE_CAR.
#' @param directMode <string> # Street modes - `WALK` - `BIKE` - `RENTAL` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs. - `CAR` - `CAR_PARKING` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs. - `CAR_DROPOFF` Experimental. Expect unannounced breaking changes (without version bumps) for all perameters and returned structs. - `ODM` on-demand taxis from the Prima+ÖV Project - `RIDE_SHARING` ride sharing from the Prima+ÖV Project - `FLEX` flexible transports # Transit modes - `TRANSIT`: translates to `TRAM,FERRY,AIRPLANE,BUS,COACH,RAIL,ODM,FUNICULAR,AERIAL_LIFT,OTHER` - `TRAM`: trams - `SUBWAY`: subway trains (Paris Metro, London Underground, but also NYC Subway, Hamburger Hochbahn, and other non-underground services) - `FERRY`: ferries - `AIRPLANE`: airline flights - `BUS`: short distance buses (does not include `COACH`) - `COACH`: long distance buses (does not include `BUS`) - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE,NIGHT_RAIL,REGIONAL_RAIL,SUBURBAN,SUBWAY` - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV) - `LONG_DISTANCE`: long distance inter city trains - `NIGHT_RAIL`: long distance night trains - `REGIONAL_FAST_RAIL`: deprecated, `REGIONAL_RAIL` will be used - `REGIONAL_RAIL`: regional train - `SUBURBAN`: suburban trains (e.g. S-Bahn, RER, Elizabeth Line, ...) - `ODM`: demand responsive transport - `FUNICULAR`: Funicular. Any rail system designed for steep inclines. - `AERIAL_LIFT`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables. - `AREAL_LIFT`: deprecated - `METRO`: deprecated - `CABLE_CAR`: deprecated
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, RIDE_SHARING, FLEX, DEBUG_BUS_ROUTE, DEBUG_RAILWAY_ROUTE, DEBUG_FERRY_ROUTE, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, SUBURBAN, FUNICULAR, AERIAL_LIFT, OTHER, AREAL_LIFT, METRO, CABLE_CAR.
#' @param maxPreTransitTime <integer> Optional. Default is 15min which is `900`. Maximum time in seconds for the first street leg. Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
#' @param maxPostTransitTime <integer> Optional. Default is 15min which is `900`. Maximum time in seconds for the last street leg. Is limited by server config variable `street_routing_max_prepost_transit_seconds`.
#' @param maxDirectTime <integer> Optional. Default is 30min which is `1800`. Maximum time in seconds for direct connections. If a value smaller than either `maxPreTransitTime` or `maxPostTransitTime` is used, their maximum is set instead. Is limited by server config variable `street_routing_max_direct_seconds`.
#' @param requireBikeTransport <boolean> Optional. Default is `false`. If set to `true`, all used transit trips are required to allow bike carriage.
#' @param requireCarTransport <boolean> Optional. Default is `false`. If set to `true`, all used transit trips are required to allow car carriage.
#' @param .body A list or object to be sent as the request body. If NULL (the default), the body will be constructed from any other top-level arguments you provide.
#' @param .return_as A string specifying the return format. Defaults to 'list'. Options are 'list' for a parsed R list, 'raw' for the raw httr2_response object, or 'string' for the raw JSON string.
#' @param .json_parser A string specifying which parser to use when .return_as = 'list'. Defaults to 'RcppSimdJson' (faster) or 'jsonlite'. Beware that their output may differ slightly.
#' @param .headers A named list of extra HTTP headers to add to the request. If no 'Accept' header is provided anywhere, 'Accept: */*' will be sent by default.
#' @param .auth An authentication token or method (e.g., a bearer token string).
#' @param .throttle_rate A number to pass to `httr2::req_throttle()` to limit the rate of requests. For example, `15/60` means 15 requests per minute. This overrides any default rate set at client generation time.
#' @param .build_only A logical. If TRUE, the function will build and return the httr2_request object without performing it. Defaults to FALSE.
#' @param .server A string to override the base URL for this specific request. If provided, it will be used instead of the default server URL.
#' @param .endpoint A string to override the path for this specific request. If provided, it will be used instead of the default path from the specification. For example, use '/v2/users' to override the endpoint path.
#' @param .referer A string to set the Referer HTTP header.
#' @param .req_options A named list of curl options passed to `httr2::req_options()`. Useful for timeouts, proxies, SSL, etc.
#' @param .handle_response A function taking an `httr2_response` and returning a value. If supplied, it overrides `.return_as` / `.json_parser` handling. See helpers like `oa3_content_or_stop()`.
#' @param .json_auto_unbox Logical. If TRUE, JSON bodies are encoded with `auto_unbox = TRUE` (jsonlite). Defaults to FALSE unless overridden.
#' @param .paginate A logical, character string, or function to enable pagination. If TRUE (or "link_header"), uses Link headers. Other options: "page_param", "cursor_param", or a custom function. See `oa3_paginate()`.
#' @export
mc_oneToManyIntermodalPost <- function(one = NULL, many = NULL, time = NULL, maxTravelTime = NULL, maxMatchingDistance = NULL, arriveBy = NULL, maxTransfers = NULL, minTransferTime = NULL, additionalTransferTime = NULL, transferTimeFactor = NULL, useRoutedTransfers = NULL, pedestrianProfile = NULL, pedestrianSpeed = NULL, cyclingSpeed = NULL, elevationCosts = NULL, transitModes = NULL, preTransitModes = NULL, postTransitModes = NULL, directMode = NULL, maxPreTransitTime = NULL, maxPostTransitTime = NULL, maxDirectTime = NULL, requireBikeTransport = NULL, requireCarTransport = NULL, .body = NULL, .return_as = NULL, .json_parser = NULL, .headers = NULL, .auth = NULL, .throttle_rate = NULL, .build_only = NULL, .server = NULL, .endpoint = NULL, .referer = NULL, .req_options = NULL, .handle_response = NULL, .json_auto_unbox = NULL, .paginate = NULL) {
  # --- Self-contained Default Arguments ---
  default_return_as <- "raw"
  default_json_parser <- "RcppSimdJson"
  default_headers <- list(Accept = "*/*")
  default_auth <- NULL
  default_throttle_rate <- NULL
  default_build_only <- TRUE
  default_server <- "http://localhost:8080"
  default_referer <- NULL
  default_req_options <- NULL
  default_json_auto_unbox <- TRUE
  default_handle_response <- NULL

  # --- Request building ---
  server_url <- .server %||% default_server
  req <- httr2::request(server_url)
  req <- httr2::req_method(req, method = "POST")

  # Path parameters
  path_params <- list()
  path_template <- .endpoint %||% "/api/experimental/one-to-many-intermodal"
  if (length(path_params)) {
    # URL-encode each path value
    for (nm in names(path_params)) path_params[[nm]] <- curl::curl_escape(as.character(path_params[[nm]]))
  }
  path_expanded <- as.character(glue::glue_data(path_params, path_template))
  req <- httr2::req_url_path_append(req, path_expanded)

  # Query parameters
  query_params <- list()
  if (length(query_params) > 0) {
    req <- do.call(httr2::req_url_query, c(list(req), query_params))
  }

  # Request body
  body_content <- .body
  # Map of formal argument names to original JSON field names
  body_map <- list(one = "one", many = "many", time = "time", maxTravelTime = "maxTravelTime", maxMatchingDistance = "maxMatchingDistance", arriveBy = "arriveBy", maxTransfers = "maxTransfers", minTransferTime = "minTransferTime", additionalTransferTime = "additionalTransferTime", transferTimeFactor = "transferTimeFactor", useRoutedTransfers = "useRoutedTransfers", pedestrianProfile = "pedestrianProfile", pedestrianSpeed = "pedestrianSpeed", cyclingSpeed = "cyclingSpeed", elevationCosts = "elevationCosts", transitModes = "transitModes", preTransitModes = "preTransitModes", postTransitModes = "postTransitModes", directMode = "directMode", maxPreTransitTime = "maxPreTransitTime", maxPostTransitTime = "maxPostTransitTime", maxDirectTime = "maxDirectTime", requireBikeTransport = "requireBikeTransport", requireCarTransport = "requireCarTransport")
  if (is.null(body_content)) {
    all_args <- as.list(environment())
    known_args <- c(NULL, '.body', '.return_as', '.json_parser', '.headers', '.auth', '.throttle_rate', '.build_only', '.server', '.endpoint', '.referer', '.req_options', '.handle_response', '.json_auto_unbox', names(body_map))
    collected <- list()
    if (length(body_map)) {
      for (nm in names(body_map)) {
        val <- all_args[[nm]]
        if (!is.null(val)) collected[[ body_map[[nm]] ]] <- val
      }
    }
    extra_names <- setdiff(names(all_args), known_args)
    # never include '...' as a body field
    extra_names <- setdiff(extra_names, '...')
    if (length(extra_names)) {
      extras <- all_args[extra_names]
      collected <- c(collected, extras)
    }
    if (length(collected)) {
      # pre-validate required body fields (by JSON key)
  required_fields <- c("one", "many")
      if (length(required_fields)) {
        missing <- setdiff(required_fields, names(collected))
        if (length(missing)) {
          stop(sprintf("Missing required request body field(s): %s", paste(missing, collapse = ", ")), call. = FALSE)
        }
      }
      body_content <- collected
    }
  }
  content_type <- "application/json"
  json_auto_unbox <- isTRUE(.json_auto_unbox %||% default_json_auto_unbox)
  array_fields <- c("many", "transitModes", "preTransitModes", "postTransitModes")
  if (!is.null(body_content) && json_auto_unbox && length(array_fields)) {
    for (key in array_fields) {
      if (!is.null(body_content[[key]]) && !is.list(body_content[[key]])) {
        body_content[[key]] <- as.list(unname(body_content[[key]]))
      }
    }
  }
  if (!is.null(body_content)) {
    if (is.null(content_type) || identical(content_type, 'application/json')) {
      req <- httr2::req_body_json(req, body_content, auto_unbox = json_auto_unbox)
    } else if (identical(content_type, 'application/x-www-form-urlencoded')) {
      req <- do.call(httr2::req_body_form, c(list(req), body_content))
    } else if (identical(content_type, 'multipart/form-data')) {
      req <- do.call(httr2::req_body_multipart, c(list(req), body_content))
    } else {
      # default to JSON if unknown
      req <- httr2::req_body_json(req, body_content, auto_unbox = json_auto_unbox)
    }
  }

  # --- Control arguments ---
  auth <- .auth %||% default_auth
  if (!is.null(auth)) {
    if (is.character(auth)) {
      req <- httr2::req_auth_bearer_token(req, auth)
    } else if (is.function(auth)) {
      req <- auth(req)
    } else {
      stop('`.auth` must be a token string or a function(req) that returns a request.', call. = FALSE)
    }
  }

  headers <- default_headers
  if (!is.null(.headers)) headers <- c(headers, .headers)
  if (!is.null(headers)) req <- do.call(httr2::req_headers, c(list(req), headers))
  # Ensure Accept exists
  if (is.null(headers) || !any(tolower(names(headers)) == 'accept')) req <- httr2::req_headers(req, Accept = '*/*')

  referer <- .referer %||% default_referer
  if (!is.null(referer)) req <- httr2::req_headers(req, Referer = referer)

  throttle_rate <- .throttle_rate %||% default_throttle_rate
  if (!is.null(throttle_rate)) req <- httr2::req_throttle(req, rate = throttle_rate)

  req_opts <- .req_options %||% default_req_options
  if (!is.null(req_opts)) {
    if (!is.list(req_opts)) stop('`.req_options` must be a named list.', call. = FALSE)
    req <- do.call(httr2::req_options, c(list(req), req_opts))
  }

  build_only <- .build_only %||% default_build_only
  if (isTRUE(build_only)) return(req)

  paginate <- .paginate %||% NULL
  if (!is.null(paginate)) {
    resps <- oa3_paginate(req, paginate)
    # If pagination is used, we return the list of responses (parsed or raw)
    # For now, we return the raw list of responses if return_as='raw',
    # otherwise we try to parse each one.
    
    return_as <- .return_as %||% default_return_as
    return_as <- if (is.null(return_as)) 'list' else as.character(return_as)[1L]
    
    if (return_as == 'raw') return(resps)
    
    json_parser <- .json_parser %||% default_json_parser
    json_parser <- if (is.null(json_parser)) 'RcppSimdJson' else as.character(json_parser)[1L]
    
    return(lapply(resps, function(resp) {
      switch(return_as,
        'string' = httr2::resp_body_string(resp),
        'list' = switch(
          json_parser,
          'RcppSimdJson' = {
             if (!requireNamespace('RcppSimdJson', quietly = TRUE)) {
               httr2::resp_body_json(resp)
             } else {
               RcppSimdJson::fparse(httr2::resp_body_string(resp))
             }
          },
          'jsonlite' = httr2::resp_body_json(resp),
          stop("Unknown .json_parser: '", json_parser, "'.", call. = FALSE)
        ),
        stop("Unknown .return_as: '", return_as, "'.", call. = FALSE)
      )
    }))
  }

  resp <- httr2::req_perform(req)

  handler <- .handle_response %||% default_handle_response
  if (!is.null(handler) && is.function(handler)) return(handler(resp))

  # Robust response handling
  return_as <- .return_as %||% default_return_as
  return_as <- if (is.null(return_as)) 'list' else as.character(return_as)[1L]
  json_parser <- .json_parser %||% default_json_parser
  json_parser <- if (is.null(json_parser)) 'RcppSimdJson' else as.character(json_parser)[1L]
  switch(return_as,
    'raw' = return(resp),
    'string' = return(httr2::resp_body_string(resp)),
    'list' = switch(
      json_parser,
      'RcppSimdJson' = {
        if (!requireNamespace('RcppSimdJson', quietly = TRUE)) {
          return(httr2::resp_body_json(resp))
        }
        RcppSimdJson::fparse(httr2::resp_body_string(resp))
      },
      'jsonlite' = httr2::resp_body_json(resp),
      stop("Unknown .json_parser: '", json_parser, "'.", call. = FALSE)
    ),
    stop("Unknown .return_as: '", return_as, "'.", call. = FALSE)
  )
}

