# Generated by the openapi3 package: do not edit by hand
# Source: openapi.yaml

#' Street routing from one to many places or many to one.
#' The order in the response array corresponds to the order of coordinates of the `many` parameter in the body.
#'
#' @param one <string> geo location as latitude;longitude
#' @param many <array> geo locations as latitude;longitude,latitude;longitude,...
#' @param mode <string> # Street modes - `WALK` - `BIKE` - `RENTAL` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs. - `CAR` - `CAR_PARKING` Experimental. Expect unannounced breaking changes (without version bumps) for all parameters and returned structs. - `CAR_DROPOFF` Experimental. Expect unannounced breaking changes (without version bumps) for all perameters and returned structs. - `ODM` on-demand taxis from the Prima+ÖV Project - `RIDE_SHARING` ride sharing from the Prima+ÖV Project - `FLEX` flexible transports # Transit modes - `TRANSIT`: translates to `TRAM,FERRY,AIRPLANE,BUS,COACH,RAIL,ODM,FUNICULAR,AERIAL_LIFT,OTHER` - `TRAM`: trams - `SUBWAY`: subway trains (Paris Metro, London Underground, but also NYC Subway, Hamburger Hochbahn, and other non-underground services) - `FERRY`: ferries - `AIRPLANE`: airline flights - `BUS`: short distance buses (does not include `COACH`) - `COACH`: long distance buses (does not include `BUS`) - `RAIL`: translates to `HIGHSPEED_RAIL,LONG_DISTANCE,NIGHT_RAIL,REGIONAL_RAIL,REGIONAL_FAST_RAIL,SUBURBAN,SUBWAY` - `HIGHSPEED_RAIL`: long distance high speed trains (e.g. TGV) - `LONG_DISTANCE`: long distance inter city trains - `NIGHT_RAIL`: long distance night trains - `REGIONAL_FAST_RAIL`: regional express routes that skip low traffic stops to be faster - `REGIONAL_RAIL`: regional train - `SUBURBAN`: suburban trains (e.g. S-Bahn, RER, Elizabeth Line, ...) - `ODM`: demand responsive transport - `FUNICULAR`: Funicular. Any rail system designed for steep inclines. - `AERIAL_LIFT`: Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables. - `AREAL_LIFT`: deprecated - `METRO`: deprecated - `CABLE_CAR`: deprecated
#' Allowed values: WALK, BIKE, RENTAL, CAR, CAR_PARKING, CAR_DROPOFF, ODM, RIDE_SHARING, FLEX, TRANSIT, TRAM, SUBWAY, FERRY, AIRPLANE, BUS, COACH, RAIL, HIGHSPEED_RAIL, LONG_DISTANCE, NIGHT_RAIL, REGIONAL_FAST_RAIL, REGIONAL_RAIL, SUBURBAN, FUNICULAR, AERIAL_LIFT, OTHER, AREAL_LIFT, METRO, CABLE_CAR.
#' @param max <number> maximum travel time in seconds
#' @param maxMatchingDistance <number> maximum matching distance in meters to match geo coordinates to the street network
#' @param elevationCosts <string> Different elevation cost profiles for street routing. Using a elevation cost profile will prefer routes with a smaller incline and smaller difference in elevation, even if the routed way is longer. - `NONE`: Ignore elevation data for routing. This is the default behavior - `LOW`: Add a low penalty for inclines. This will favor longer paths, if the elevation increase and incline are smaller. - `HIGH`: Add a high penalty for inclines. This will favor even longer paths, if the elevation increase and incline are smaller.
#' Allowed values: NONE, LOW, HIGH.
#' @param arriveBy <boolean> true = many to one false = one to many
#' @param .body A list or object to be sent as the request body. If NULL (the default), the body will be constructed from any other top-level arguments you provide.
#' @param .return_as A string specifying the return format. Defaults to 'list'. Options are 'list' for a parsed R list, 'raw' for the raw httr2_response object, or 'string' for the raw JSON string.
#' @param .json_parser A string specifying which parser to use when .return_as = 'list'. Defaults to 'RcppSimdJson' (faster) or 'jsonlite'. Beware that their output may differ slightly.
#' @param .headers A named list of extra HTTP headers to add to the request. If no 'Accept' header is provided anywhere, 'Accept: */*' will be sent by default.
#' @param .auth An authentication token or method (e.g., a bearer token string).
#' @param .throttle_rate A number to pass to `httr2::req_throttle()` to limit the rate of requests. For example, `15/60` means 15 requests per minute. This overrides any default rate set at client generation time.
#' @param .build_only A logical. If TRUE, the function will build and return the httr2_request object without performing it. Defaults to FALSE.
#' @param .server A string to override the base URL for this specific request. If provided, it will be used instead of the default server URL.
#' @param .endpoint A string to override the path for this specific request. If provided, it will be used instead of the default path from the specification. For example, use '/v2/users' to override the endpoint path.
#' @param .referer A string to set the Referer HTTP header.
#' @param .req_options A named list of curl options passed to `httr2::req_options()`. Useful for timeouts, proxies, SSL, etc.
#' @param .handle_response A function taking an `httr2_response` and returning a value. If supplied, it overrides `.return_as` / `.json_parser` handling. See helpers like `oa3_content_or_stop()`.
#' @param .json_auto_unbox Logical. If TRUE, JSON bodies are encoded with `auto_unbox = TRUE` (jsonlite). Defaults to FALSE unless overridden.
#' @param .paginate A logical, character string, or function to enable pagination. If TRUE (or "link_header"), uses Link headers. Other options: "page_param", "cursor_param", or a custom function. See `oa3_paginate()`.
#' @export
mc_oneToManyPost <- function(one = NULL, many = NULL, mode = NULL, max = NULL, maxMatchingDistance = NULL, elevationCosts = NULL, arriveBy = NULL, .body = NULL, .return_as = NULL, .json_parser = NULL, .headers = NULL, .auth = NULL, .throttle_rate = NULL, .build_only = NULL, .server = NULL, .endpoint = NULL, .referer = NULL, .req_options = NULL, .handle_response = NULL, .json_auto_unbox = NULL, .paginate = NULL) {
  # --- Self-contained Default Arguments ---
  default_return_as <- "raw"
  default_json_parser <- "RcppSimdJson"
  default_headers <- list(Accept = "*/*")
  default_auth <- NULL
  default_throttle_rate <- NULL
  default_build_only <- TRUE
  default_server <- "http://localhost:8080"
  default_referer <- NULL
  default_req_options <- NULL
  default_json_auto_unbox <- TRUE
  default_handle_response <- NULL

  # --- Request building ---
  server_url <- .server %||% default_server
  req <- httr2::request(server_url)
  req <- httr2::req_method(req, method = "POST")

  # Path parameters
  path_params <- list()
  path_template <- .endpoint %||% "/api/v1/one-to-many"
  if (length(path_params)) {
    # URL-encode each path value
    for (nm in names(path_params)) path_params[[nm]] <- curl::curl_escape(as.character(path_params[[nm]]))
  }
  path_expanded <- as.character(glue::glue_data(path_params, path_template))
  req <- httr2::req_url_path_append(req, path_expanded)

  # Query parameters
  query_params <- list()
  if (length(query_params) > 0) {
    req <- do.call(httr2::req_url_query, c(list(req), query_params))
  }

  # Request body
  body_content <- .body
  # Map of formal argument names to original JSON field names
  body_map <- list(one = "one", many = "many", mode = "mode", max = "max", maxMatchingDistance = "maxMatchingDistance", elevationCosts = "elevationCosts", arriveBy = "arriveBy")
  if (is.null(body_content)) {
    all_args <- as.list(environment())
    known_args <- c(NULL, '.body', '.return_as', '.json_parser', '.headers', '.auth', '.throttle_rate', '.build_only', '.server', '.endpoint', '.referer', '.req_options', '.handle_response', '.json_auto_unbox', names(body_map))
    collected <- list()
    if (length(body_map)) {
      for (nm in names(body_map)) {
        val <- all_args[[nm]]
        if (!is.null(val)) collected[[ body_map[[nm]] ]] <- val
      }
    }
    extra_names <- setdiff(names(all_args), known_args)
    # never include '...' as a body field
    extra_names <- setdiff(extra_names, '...')
    if (length(extra_names)) {
      extras <- all_args[extra_names]
      collected <- c(collected, extras)
    }
    if (length(collected)) {
      # pre-validate required body fields (by JSON key)
  required_fields <- c("one", "many", "mode", "max", "maxMatchingDistance", "elevationCosts", "arriveBy")
      if (length(required_fields)) {
        missing <- setdiff(required_fields, names(collected))
        if (length(missing)) {
          stop(sprintf("Missing required request body field(s): %s", paste(missing, collapse = ", ")), call. = FALSE)
        }
      }
      body_content <- collected
    }
  }
  content_type <- "application/json"
  json_auto_unbox <- isTRUE(.json_auto_unbox %||% default_json_auto_unbox)
  array_fields <- c("many")
  if (!is.null(body_content) && json_auto_unbox && length(array_fields)) {
    for (key in array_fields) {
      if (!is.null(body_content[[key]]) && !is.list(body_content[[key]])) {
        body_content[[key]] <- as.list(unname(body_content[[key]]))
      }
    }
  }
  if (!is.null(body_content)) {
    if (is.null(content_type) || identical(content_type, 'application/json')) {
      req <- httr2::req_body_json(req, body_content, auto_unbox = json_auto_unbox)
    } else if (identical(content_type, 'application/x-www-form-urlencoded')) {
      req <- do.call(httr2::req_body_form, c(list(req), body_content))
    } else if (identical(content_type, 'multipart/form-data')) {
      req <- do.call(httr2::req_body_multipart, c(list(req), body_content))
    } else {
      # default to JSON if unknown
      req <- httr2::req_body_json(req, body_content, auto_unbox = json_auto_unbox)
    }
  }

  # --- Control arguments ---
  auth <- .auth %||% default_auth
  if (!is.null(auth)) {
    if (is.character(auth)) {
      req <- httr2::req_auth_bearer_token(req, auth)
    } else if (is.function(auth)) {
      req <- auth(req)
    } else {
      stop('`.auth` must be a token string or a function(req) that returns a request.', call. = FALSE)
    }
  }

  headers <- default_headers
  if (!is.null(.headers)) headers <- c(headers, .headers)
  if (!is.null(headers)) req <- do.call(httr2::req_headers, c(list(req), headers))
  # Ensure Accept exists
  if (is.null(headers) || !any(tolower(names(headers)) == 'accept')) req <- httr2::req_headers(req, Accept = '*/*')

  referer <- .referer %||% default_referer
  if (!is.null(referer)) req <- httr2::req_headers(req, Referer = referer)

  throttle_rate <- .throttle_rate %||% default_throttle_rate
  if (!is.null(throttle_rate)) req <- httr2::req_throttle(req, rate = throttle_rate)

  req_opts <- .req_options %||% default_req_options
  if (!is.null(req_opts)) {
    if (!is.list(req_opts)) stop('`.req_options` must be a named list.', call. = FALSE)
    req <- do.call(httr2::req_options, c(list(req), req_opts))
  }

  build_only <- .build_only %||% default_build_only
  if (isTRUE(build_only)) return(req)

  paginate <- .paginate %||% NULL
  if (!is.null(paginate)) {
    resps <- oa3_paginate(req, paginate)
    # If pagination is used, we return the list of responses (parsed or raw)
    # For now, we return the raw list of responses if return_as='raw',
    # otherwise we try to parse each one.
    
    return_as <- .return_as %||% default_return_as
    return_as <- if (is.null(return_as)) 'list' else as.character(return_as)[1L]
    
    if (return_as == 'raw') return(resps)
    
    json_parser <- .json_parser %||% default_json_parser
    json_parser <- if (is.null(json_parser)) 'RcppSimdJson' else as.character(json_parser)[1L]
    
    return(lapply(resps, function(resp) {
      switch(return_as,
        'string' = httr2::resp_body_string(resp),
        'list' = switch(
          json_parser,
          'RcppSimdJson' = {
             if (!requireNamespace('RcppSimdJson', quietly = TRUE)) {
               httr2::resp_body_json(resp)
             } else {
               RcppSimdJson::fparse(httr2::resp_body_string(resp))
             }
          },
          'jsonlite' = httr2::resp_body_json(resp),
          stop("Unknown .json_parser: '", json_parser, "'.", call. = FALSE)
        ),
        stop("Unknown .return_as: '", return_as, "'.", call. = FALSE)
      )
    }))
  }

  resp <- httr2::req_perform(req)

  handler <- .handle_response %||% default_handle_response
  if (!is.null(handler) && is.function(handler)) return(handler(resp))

  # Robust response handling
  return_as <- .return_as %||% default_return_as
  return_as <- if (is.null(return_as)) 'list' else as.character(return_as)[1L]
  json_parser <- .json_parser %||% default_json_parser
  json_parser <- if (is.null(json_parser)) 'RcppSimdJson' else as.character(json_parser)[1L]
  switch(return_as,
    'raw' = return(resp),
    'string' = return(httr2::resp_body_string(resp)),
    'list' = switch(
      json_parser,
      'RcppSimdJson' = {
        if (!requireNamespace('RcppSimdJson', quietly = TRUE)) {
          return(httr2::resp_body_json(resp))
        }
        RcppSimdJson::fparse(httr2::resp_body_string(resp))
      },
      'jsonlite' = httr2::resp_body_json(resp),
      stop("Unknown .json_parser: '", json_parser, "'.", call. = FALSE)
    ),
    stop("Unknown .return_as: '", return_as, "'.", call. = FALSE)
  )
}

